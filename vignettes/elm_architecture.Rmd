---
title: "elm architecture"
author: "Martin Westgate"
date: "2024-08-14"
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{elm architecture}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `elm` package converts markdown files to ecological meta-language (EML). 
Transformations of this type are valuable for sharing metadata in several 
contexts, particularly in the life sciences, where EML is widely used to provide 
metadata in machine-readable format. EML is a standard that uses xml structures,
but it's own bespoke naming conventions; but is considerably more difficult to 
read and edit than text-based formats such as markdown.

## Methodological approach

To convert between markdown and EML, `elm` relies on the assumption that header
levels in markdown reflect the nestedness structure of the resulting xml. For
example, the markdown file might contain this text:

```
# EML
## Dataset
### Title
My title
```

Which would parse to this in xml:
```
<EML>
  <dataset>
    <title>My title</title>
  </dataset>
<EML>
```

To accomplish this conversion, we have built a set of parsers that convert
data in this sequence:

```
.md file -> character -> tibble -> list -> xml -> .xml file
```
We have also built the inverse parsers to convert back from `.xml` to `.md`. All
parsers are named in the form `parse_{class1}_to_{class2}`; so to convert a 
character to a tibble, for example, we use `parse_chr_to_tibble()`:

```{r}
library(elm)

c("# Heading 1", 
  "## Heading 2",
  "text content") |>
  parse_chr_to_tibble()
```

While this parser is new, parsing between xml and lists is handled entirely by 
the `xml2` package. All new parsers in `elm` are built to plug into the formats 
defined by `xml2`.

## Generic transformers

While these low-level parsers are critical, they are fairly verbose. They also
only handle one 'link' in the chain each, meaning that to complete the whole
'chain', we would need to string them together:

```{r}
library(elm)

c("# Heading 1", 
  "## Heading 2",
  "text content") |>
  parse_chr_to_tibble() |>
  parse_tibble_to_list() |>
  parse_list_to_xml()
```

Clearly this isn't ideal; we would prefer to use object-oriented programming
to specify our preferred output format. In practice, however, this is tricky,
because we are using such common formats that overwritting e.g. `as.list()`
isn't feasible. Conversely, creating new, bespoke S3 formats is also not ideal,
as it would be nice to parse _any_ character, tibble, list or xml_document,
not just those that are created using `elm`. 

To avoid these problems, `elm` uses the `as_elm_` prefix for all transformations,
rather than the more generic `as`. This adds a degree of flexibility without 
have to define a large number of new object classes. To give a concrete example, 
the problem in the previous code block can now be solved using only one 
function:

```{r}
c("# Heading 1", 
  "## Heading 2",
  "text content") |>
  as_elm_xml()
```

Every permutation of `as_elm_` functions is provided in `elm`, meaning you can 
simply choose the outcome you are looking for, and let `elm` handle the 
parsing chain needed to return the object class you require.

## Reading and writing

As is standard for ALA R packages, `read_` functions in `elm` return a `tibble`.
By default, `read_elm()` will detect file type based on suffix:

```{r}
file <- system.file("example_data", 
                    "README_md_example.md", 
                    package = "elm")
read_elm(file)
```

However, you can specify the suffix using either the `format` argument, or using 
a more specific microfunction:

```{r}
read_elm_xml("https://collections.ala.org.au/ws/eml/dr368") # same as read_elm()
```

The corresponding write function is `write_elm()`. This function accepts objects 
of all classes supported by `elm`, so it is possible to chain read and write 
functions together without any intermediate stages:

```{r, eval=FALSE}
system.file("example_data", 
            "README_md_example.md", 
            package = "elm") |>
  read_elm() |>
  write_elm("output.xml")
```

It is worth noting, though, that these are quite simple wrapper functions to 
existing import and transformation functions. For example, the code block above
can be rewritten using only one `elm` function, as follows:

```{r, eval=FALSE}
library(xml2)

system.file("example_data", 
            "README_md_example.md", 
            package = "elm") |>
  base::readLines() |>
  elm::as_elm_xml() |>
  xml2::write_xml("output.xml")
```
