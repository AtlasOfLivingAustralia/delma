---
title: "elm architecture"
author: "Martin Westgate"
date: "2024-08-14"
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{elm architecture}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `elm` package converts markdown files to Ecological Metadata Language (EML),
which is a "comprehensive vocabulary and a readable XML markup syntax for 
documenting research data" 
([Jones et al. 2019](https://doi.org/10.5063/F11834T2)). EML has been widely
adopted as a community-maintained standard for metadata exchange, to the point 
that supplying metadata in this format is a requirement of several data-sharing
institutions, such as the Global Biodiversity Information Facility
([GBIF](https://gbif.org])) and its partner nodes. Unfortunately, however, the 
nested structure and xml formatting of EML make it difficult for people to use
without drawing on bespoke programming tools. In contrast, markdown is 
considerably more generic, especially for those who are familiar with tools such 
as RMarkdown or Quarto; but no general-purpose parser exists to transform 
markdown into EML. `elm` fills this gap.

## Methodological approach

To convert between markdown and EML, `elm` relies on the assumption that header
levels in markdown reflect the nested structure of the resulting xml. For
example, the markdown file might contain this text:

```
# EML
## Dataset
### Title
My title
```

Which would parse to this in xml:
```
<EML>
  <dataset>
    <title>My title</title>
  </dataset>
<EML>
```

To accomplish this conversion, we have built a set of parsers that convert
data in this sequence:

```
.md file -> character -> tibble -> list -> xml -> .xml file
```
We have also built the inverse parsers to convert back from `.xml` to `.md`. All
parsers are named in the form `parse_{class1}_to_{class2}`; so to convert a 
character to a tibble, for example, we use `parse_chr_to_tibble()`:

```{r}
library(elm)

c("# Heading 1", 
  "## Heading 2",
  "text content") |>
  parse_chr_to_tibble()
```

While this parser is new, parsing between xml and lists is handled entirely by 
the `xml2` package. All new parsers in `elm` are built to plug into the formats 
defined by `xml2`.

## Generic transformers

While these low-level parsers are critical, they are fairly verbose. They also
only handle one 'link' in the parsing 'chain' each, meaning that to complete the 
whole operation, we would need to pipe them together in sequence:

```{r}
library(elm)

c("# Heading 1", 
  "## Heading 2",
  "text content") |>
  parse_chr_to_tibble() |>
  parse_tibble_to_list() |>
  parse_list_to_xml()
```

Clearly this isn't ideal; we would prefer to use object-oriented programming
to specify our preferred output format. In practice, however, it would be 
undesirable to overwrite existing functions such as `base::as.list()` or
`tibble::as_tibble()` with more EML-specific variants, as these would have a
high chance of breaking existing code. Nor would it be desirable to create
new, bespoke S3 classes for the `elm` package, as it would be nice to parse
_any_ character, tibble, list or xml_document, not just those that are created 
using `elm`.

To avoid these problems, `elm` uses the `as_eml_` prefix for all transformations,
rather than the more generic `as`. This adds a degree of flexibility without 
having to define any new object classes. To give a concrete example, the problem 
in the previous code block can now be solved using only one function:

```{r}
c("# Heading 1", 
  "## Heading 2",
  "text content") |>
  as_eml_xml()
```

Every permutation of `as_eml_` functions is provided in `elm`, meaning you can 
simply choose the outcome you are looking for, and let `elm` handle the 
parsing chain needed to return the object class you require.

## Reading and writing

As is standard for ALA R packages, `read_` functions in `elm` return a `tibble`.
There are two variants, one for reading data from markdown:

```{r}
file <- system.file("example_data", 
                    "README_md_example.md", 
                    package = "elm")
read_md(file)
```

And a second for reading data from EML:

```{r}
read_eml("https://collections.ala.org.au/ws/eml/dr368")
```

The corresponding write functions are `write_md()` and `write_eml()`. Both
functions accept objects of all classes supported by `elm`, so it is possible 
to pipe read and write functions together without any intermediate stages:

```{r, eval=FALSE}
system.file("example_data", 
            "README_md_example.md", 
            package = "elm") |>
  read_md() |>
  write_eml("output.xml")
```

It is worth noting, though, that these are quite simple wrapper functions to 
existing import and transformation functions. For example, the code block above
can be rewritten using only one `elm` function, as follows:

```{r, eval=FALSE}
library(xml2)

system.file("example_data", 
            "README_md_example.md", 
            package = "elm") |>
  base::readLines() |>
  elm::as_eml_xml() |>
  xml2::write_xml("output.xml")
```
